#' ---
#' title: "meuse_vignette"
#' author: "Dean Koch"
#' date: "`r format(Sys.Date())`"
#' output: github_document
#' ---
#'
#' **Mitacs UYRW project**
#'
#' **snapKrig**: Fast kriging on gridded datasets
#'
#' This vignette shows how to use `snapKrig` to interpolate the Meuse river dataset
#' (part of the `sp` package) onto a high resolution grid:
#'
#' * `sk_grid` defines the grid
#' * `sk_snap` snaps point data to the grid
#' * `sk_fit` fits a covariance model to the data
#' * `sk_cmean` computes the kriging predictor and variance
#'
#' All plots in this document except the first are generated by `sk_plot`, which uses base graphics
#' to display rasters and matrices. Try setting `ij=TRUE` in any of the plot calls to see a different
#' styling used for matrices.
#'
#' ## Getting started
#'
#' `snapKrig` has no requirements outside of base packages (`stats`, `utils`, `grDevices`, and `graphics`),
#' but `terra` and `sf` are (strongly) suggested, and we use them in this vignette to load and manage
#' the example data.
#'

#+ dependencies_hide, include=FALSE

# load snapKrig
library(devtools)
load_all()

#+ dependencies

# load extra dependencies for the vignette
library(sp)
library(sf)
library(terra)

#'
#' ## Example data
#'
#' We will look at the "meuse" dataset (Pebesma, 2009) on heavy metal concentrations in the Meuse
#' river floodplain in the Netherlands. These data are included with the `sp` package that we just
#' loaded, and appear in this
#' [tutorial pdf](https://cran.r-project.org/web/packages/gstat/vignettes/gstat.pdf)
#' for gstat. Load the data with `data(meuse)` and `data(meuse.riv)`. I have a helper function
#' `get_meuse` to do this (see source code for this document).

#+ meuse_hide, include=FALSE

# load the Meuse data into a convenient format
get_meuse = function(dfMaxLength = units::set_units(50, m))
{
  # Note: dfMaxLength sets the interval used to sample line geometries of the river
  # using Voronoi tiles. This is a fussy and not well-tested algorithm for finding the
  # centre line of a river polygon, but it seems to work well enough for the example here

  # EPSG code for the coordinate system
  epsg_meuse = 28992

  # open river location data
  utils::data(meuse.riv)
  crs_meuse = sf::st_crs(epsg_meuse)[['wkt']]

  # reshape the river (edge) point data as a more densely segmented polygon
  colnames(meuse.riv) = c('x', 'y')
  meuse_river_points = sf::st_as_sf(as.data.frame(meuse.riv), coords=c('x', 'y'), crs=crs_meuse)
  meuse_river_seg = sf::st_cast(sf::st_combine(meuse_river_points), 'LINESTRING')
  meuse_river_poly = sf::st_cast(st_segmentize(meuse_river_seg, dfMaxLength), 'POLYGON')

  # skeletonization trick to get a single linestring at center of the river
  meuse_river_voronoi = sf::st_cast(sf::st_voronoi(meuse_river_poly, bOnlyEdges=TRUE), 'POINT')
  meuse_river_skele = sf::st_intersection(meuse_river_voronoi, meuse_river_poly)
  n_skele = length(meuse_river_skele)

  # compute distance matrix
  dmat_skele = units::drop_units(sf::st_distance(meuse_river_skele))

  # re-order to start from northernmost point
  idx_first = which.max(st_coordinates(meuse_river_skele)[,2])
  idx_reorder = c(idx_first, integer(n_skele-1L))
  for(idx_skele in seq(n_skele-1L))
  {
    # find least distance match
    idx_tocheck = seq(n_skele) != idx_first
    idx_first = which(idx_tocheck)[ which.min(dmat_skele[idx_tocheck, idx_first]) ]
    idx_reorder[1L+idx_skele] = idx_first

    # modify distance matrix so the matching point is not selected again
    dmat_skele[idx_first, ] = Inf
  }

  # connect the points to get the spine
  meuse_river = sf::st_cast(sf::st_combine(meuse_river_skele[idx_reorder]), 'LINESTRING')

  # load soil points data
  utils::data(meuse)
  meuse_soils = sf::st_as_sf(meuse, coords=c('x', 'y'), crs=epsg_meuse)

  # add 'distance' (to river) and 'logzinc' columns
  meuse_soils[['distance']] = units::drop_units( sf::st_distance(meuse_soils, meuse_river))
  meuse_soils[['log_zinc']] = log(meuse_soils[['zinc']])

  # crop the river objects to buffered bounding box of soils data
  bbox_padded = st_buffer(sf::st_as_sfc(sf::st_bbox(meuse_soils)), units::set_units(500, m))
  meuse_river_poly = sf::st_crop(meuse_river_poly, bbox_padded)
  meuse_river = sf::st_crop(meuse_river, bbox_padded)

  # return three geometry objects in a list
  return( list(soils=meuse_soils, river_poly=meuse_river_poly, river_line=meuse_river) )
}

#+ meuse_load

# load data
meuse = get_meuse()
str(meuse)

# plot using sf package
plot(meuse[['river_poly']], col='lightblue', reset=FALSE)
plot(meuse[['river_line']], lwd=2, add=TRUE)
plot(meuse[['soils']]['zinc'], pch=16, add=TRUE)
n_meuse = nrow(meuse[['soils']])

#'
#' We will interpolate the log-transformed values (as in the `gstat` vignette). Start by
#' defining a grid and snapping the points to it
#'

#+ snap_grid

# desired resolution in units of metres
gres = c(y=5, x=5)

# snap points, copying values of dependent variable
g_meuse = sk_snap(meuse[['soils']]['log_zinc'], g=list(gres=gres))

# make an empty copy of this grid
g_empty = g_meuse
g_empty[] = NULL

#' # functions to scale arbitrary inverval to (1, 2,... 100) and make color palettes
num_to_cent = function(x) 1L + floor(99*( x-min(x) ) / diff(range(x)))
my_pal = function(x) hcl.colors(x, 'Spectral', rev=T)
my_col = function(x) my_pal(1e2)[ num_to_cent(x) ]

# plot with source points indicated over their snapped grid location
plot(g_meuse, zlab='log(zinc)', reset=FALSE)
plot(meuse[['soils']]['log_zinc'], add=TRUE, pch=16, pal=my_pal)
plot(meuse[['soils']]['log_zinc'], add=TRUE, col='black')

# add faint lines to indicate the selected grid points
gcol = adjustcolor('black', alpha.f=0.1)
abline(v=sk_coords(g_meuse, na_omit=TRUE)[,'x'], xpd=FALSE, col=gcol)
abline(h=sk_coords(g_meuse, na_omit=TRUE)[,'y'], xpd=FALSE, col=gcol)

#'
#' Pass this data to sk_fit to do ordinary kriging
#'

#+ ordinary_kriging

# ordinary kriging: fit isotropic gaussian model by default
fit_result_OK = sk_fit(g_meuse, quiet=TRUE)
#fit_result_OK = sk_fit(g_obs=g_meuse, pars='mat', quiet=TRUE)
#vg_detrend = sk_sample_vg(g_meuse)
#sk_plot_semi(vg_detrend, fit_result_OK$pars)


#'
#' By default, a sample semi-variogram is plotted, with the fitted model
#' drawn in transparent blue. Notice that a range of semi-variances can be
#' realized for a given distance because the model is anisotropic.
#'
#' The fitted model overestimates the (partial sill) variance in this case because
#' there is an unaccounted-for trend. Ordinary kriging estimates spatially constant
#' trends, but here we should expect it to depend on how near we are to the presumed
#' source of the zinc deposits (the Meuse River).
#'
#' The code below demonstrates creating a linear predictor - the distance to the river.
#'

#+ make_distances

# display then copy some info about the grid
summary(g_meuse)
gdim = dim(g_meuse)
is_obs = !is.na(g_meuse)
n = length(g_meuse)
n_obs = sum(is_obs)

# get distance values for entire grid
g_meuse_sf = sk_coords(g_meuse, out='sf')
d2r_result = units::drop_units(st_distance(g_meuse_sf, meuse[['river_line']]))

# include both distance and its square root
meuse_predictors = scale(cbind(d2r_result, sqrt(d2r_result)))

# copy the subset of predictors at observed response locations
X = matrix(meuse_predictors[is_obs,], nrow=n_obs)


#'
#' Fit the model with the linear predictor included. This is called universal kriging
#'

#+ universal_kriging

# fit the model and plot semivariogram
fit_result_UK = sk_fit(g_obs=g_meuse, X=X, quiet=TRUE)

# print the GLS estimates for coefficients of the linear predictor
pars_UK = fit_result_UK$pars
sk_GLS(g_meuse, pars_UK, X=X, out='b')

#'
#' These fitted kernels can be visualized using `sk_plot_pars`. This plots the
#' footprint of correlations around any given central point on the grid.
#'

#+ kernel_plot

# plot the kernel shape
sk_plot_pars(pars_UK, g_meuse)

# print the actual contents of the parameters list
str(pars_UK)


#+ GLS_plot



# GLS to estimate the (spatially varying) trend
g_lm = g_empty
g_lm[] = sk_GLS(g_meuse, pars_UK, X=meuse_predictors, out='z')
plot(g_lm, main='estimated trend component')

# g2 = g_meuse
# g2[['gval']] = g2[['gval']] - z_gls
# vg_detrend = sk_sample_vg(g2)
# sk_plot_semi(vg_detrend, pars_UK, fun='classical')
# sk_plot_semi(vg_detrend, pars_UK, fun='root_median')



#'
#' Once you have a set of covariance parameters, interpolation becomes very easy
#' with `sk_cmean`. This computes the kriging predictor, an interpolator with nice
#' properties like unbiasedness and minimal variance, under suitable assumptions.
#'

#+ spatial_plot



# compute expectation (UK kriging predictor)
g_pred = g_empty
g_pred[] = sk_cmean(g_meuse, pars_UK, X=meuse_predictors)


#+ predictor_plot
#+

# plot UK predictions, mask to observed range
zlim_pred = range(g_meuse, na.rm=TRUE)
plot(g_pred, zlim=zlim_pred, zlab='log(zinc)', main='kriging predictor')

#'
#' Kriging variance is also computed with `sk_cmean`. This is much slower
#' to compute than the kriging predictor
#'

#+ variance_plot




# prediction variance
g_var = g_empty
g_var[] = sk_cmean(g_meuse, pars_UK, X=meuse_predictors, out='v', quiet=TRUE)


# plot
zlim_var = c(pars_UK[['eps']], pars_UK[['eps']] + pars_UK[['psill']])
sk_plot(g_var, main='kriging variance', zlim=zlim_var)




#'
#' The above plots are for the variable on the log-scale. The unbiasedness property
#' is lost when transforming back to the original scale, but now that we have the
#' kriging variance, we can make a correction:
#'

#+ predictor

# prediction bias adjustment from log scale
g_pred_adj = exp(g_pred + g_var/2)

sk_plot(g_pred_adj, zlab='zinc (ppm)', main='UK predictions (masked to input range)', zlim=exp(zlim_pred))


#'
#' ## Summary
#'
#' This vignette is intended to get users up and running with `snapKrig` by demonstrating
#' a very simple example on a familiar dataset. In other vignettes we will look in more
#' detail at how `sk_cmean` actually works, and how users can modify the workflow to
#' incorporate a trend model.


#'
#' ## Markdown
#'
#' This chunk below is used to create the markdown document you're reading from the
#' R script file with same name, in this directory. It uses `rmarkdown` to create
#' the md file, then substitutes local image paths for github URLs so the document
#' will display the images properly on my repo page.

if(FALSE)
{
  # Restart session and run code chunk below to build the markdown file
  library(here)
  library(rmarkdown)

  # make the markdown document and delete the unwanted html
  path.input = here('vignettes/meuse_vignette.R')
  path.output = here('vignettes/meuse_vignette.md')
  path.garbage = here('vignettes/meuse_vignette.html')
  rmarkdown::render(path.input, clean=TRUE, output_file=path.output)
  unlink(path.garbage)

  # substitute local file paths for image files with URLs on github
  md.github = gsub('D:/snapKrig', 'https://github.com/deankoch/snapKrig/blob/master', readLines(path.output))
  writeLines(md.github, path.output)
}
