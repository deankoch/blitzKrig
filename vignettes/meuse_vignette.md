meuse_vignette
================
Dean Koch
2022-10-13

**Mitacs UYRW project**

**snapKrig**: Fast kriging on gridded datasets

This vignette shows how to use `snapKrig` to interpolate the Meuse river
dataset (part of the `sp` package) onto a high resolution grid:

-   `sk_grid` defines the grid
-   `sk_snap` snaps point data to the grid
-   `sk_fit` fits a covariance model to the data
-   `sk_cmean` computes the kriging predictor and variance

All plots in this document except the first are generated by `sk_plot`,
which uses base graphics to display rasters and matrices. Try setting
`ij=TRUE` in any of the plot calls to see a different styling used for
matrices.

## Getting started

`snapKrig` has no requirements outside of base packages (`stats`,
`utils`, `grDevices`, and `graphics`), but `terra` and `sf` are
(strongly) suggested, and we use them in this vignette to load and
manage the example data.

``` r
# load extra dependencies for the vignette
library(sp)
library(sf)
```

    ## Linking to GEOS 3.9.1, GDAL 3.4.3, PROJ 7.2.1; sf_use_s2() is TRUE

``` r
library(terra)
```

    ## terra 1.6.17

## Example data

We will look at the “meuse” dataset (Pebesma, 2009) on heavy metal
concentrations in the Meuse river floodplain in the Netherlands. These
data are included with the `sp` package that we just loaded, and appear
in this [tutorial
pdf](https://cran.r-project.org/web/packages/gstat/vignettes/gstat.pdf)
for gstat. Load the data with `data(meuse)` and `data(meuse.riv)`. I
have a helper function `get_meuse` to do this (see source code for this
document).

``` r
# load data
meuse = get_meuse()
str(meuse)
```

    ## List of 3
    ##  $ soils     :Classes 'sf' and 'data.frame': 155 obs. of  15 variables:
    ##   ..$ cadmium : num [1:155] 11.7 8.6 6.5 2.6 2.8 3 3.2 2.8 2.4 1.6 ...
    ##   ..$ copper  : num [1:155] 85 81 68 81 48 61 31 29 37 24 ...
    ##   ..$ lead    : num [1:155] 299 277 199 116 117 137 132 150 133 80 ...
    ##   ..$ zinc    : num [1:155] 1022 1141 640 257 269 ...
    ##   ..$ elev    : num [1:155] 7.91 6.98 7.8 7.66 7.48 ...
    ##   ..$ dist    : num [1:155] 0.00136 0.01222 0.10303 0.19009 0.27709 ...
    ##   ..$ om      : num [1:155] 13.6 14 13 8 8.7 7.8 9.2 9.5 10.6 6.3 ...
    ##   ..$ ffreq   : Factor w/ 3 levels "1","2","3": 1 1 1 1 1 1 1 1 1 1 ...
    ##   ..$ soil    : Factor w/ 3 levels "1","2","3": 1 1 1 2 2 2 2 1 1 2 ...
    ##   ..$ lime    : Factor w/ 2 levels "0","1": 2 2 2 1 1 1 1 1 1 1 ...
    ##   ..$ landuse : Factor w/ 15 levels "Aa","Ab","Ag",..: 4 4 4 11 4 11 4 2 2 15 ...
    ##   ..$ dist.m  : num [1:155] 50 30 150 270 380 470 240 120 240 420 ...
    ##   ..$ geometry:sfc_POINT of length 155; first list element:  'XY' num [1:2] 181072 333611
    ##   ..$ distance: num [1:155, 1] 118 125 232 359 482 ...
    ##   ..$ log_zinc: num [1:155] 6.93 7.04 6.46 5.55 5.59 ...
    ##   ..- attr(*, "sf_column")= chr "geometry"
    ##   ..- attr(*, "agr")= Factor w/ 3 levels "constant","aggregate",..: NA NA NA NA NA NA NA NA NA NA ...
    ##   .. ..- attr(*, "names")= chr [1:14] "cadmium" "copper" "lead" "zinc" ...
    ##  $ river_poly:sfc_POLYGON of length 1; first list element: List of 1
    ##   ..$ : num [1:413, 1:2] 181505 181478 181452 181420 181388 ...
    ##   ..- attr(*, "class")= chr [1:3] "XY" "POLYGON" "sfg"
    ##  $ river_line:sfc_LINESTRING of length 1; first list element:  'XY' num [1:409, 1:2] 181444 181425 181412 181398 181379 ...

``` r
# plot using sf package
plot(meuse[['river_poly']], col='lightblue', reset=FALSE)
plot(meuse[['river_line']], lwd=2, add=TRUE)
plot(meuse[['soils']]['zinc'], pch=16, add=TRUE)
```

![](https://github.com/deankoch/snapKrig/blob/master/vignettes/meuse_vignette_files/figure-gfm/meuse_load-1.png)<!-- -->

``` r
n_meuse = nrow(meuse[['soils']])
```

We will interpolate the log-transformed values (as in the `gstat`
vignette). Start by defining a grid and snapping the points to it

``` r
# desired resolution in units of metres
gres = c(y=5, x=5)

# snap points, copying values of dependent variable
g_meuse = sk_snap(meuse[['soils']]['log_zinc'], g=list(gres=gres))
```

    ## processing all 4 grid points...
    ## maximum snapping distance: 2.82842712474619

``` r
# make an empty copy of this grid
g_empty = g_meuse
g_empty[] = NULL
```

# functions to scale arbitrary inverval to (1, 2,… 100) and make color palettes

``` r
num_to_cent = function(x) 1L + floor(99*( x-min(x) ) / diff(range(x)))
my_pal = function(x) hcl.colors(x, 'Spectral', rev=T)
my_col = function(x) my_pal(1e2)[ num_to_cent(x) ]

# plot with source points indicated over their snapped grid location
plot(g_meuse, zlab='log(zinc)', reset=FALSE)
plot(meuse[['soils']]['log_zinc'], add=TRUE, pch=16, pal=my_pal)
plot(meuse[['soils']]['log_zinc'], add=TRUE, col='black')

# add faint lines to indicate the selected grid points
gcol = adjustcolor('black', alpha.f=0.1)
abline(v=sk_coords(g_meuse, na_omit=TRUE)[,'x'], xpd=FALSE, col=gcol)
```

    ## processing all 435240 grid points...

``` r
abline(h=sk_coords(g_meuse, na_omit=TRUE)[,'y'], xpd=FALSE, col=gcol)
```

![](https://github.com/deankoch/snapKrig/blob/master/vignettes/meuse_vignette_files/figure-gfm/unnamed-chunk-1-1.png)<!-- -->

    ## processing all 435240 grid points...

Pass this data to sk_fit to do ordinary kriging

``` r
# ordinary kriging: fit isotropic gaussian model by default
fit_result_OK = sk_fit(g_meuse, quiet=TRUE)
#fit_result_OK = sk_fit(g_obs=g_meuse, pars='mat', quiet=TRUE)
#vg_detrend = sk_sample_vg(g_meuse)
#sk_plot_semi(vg_detrend, fit_result_OK$pars)
```

By default, a sample semi-variogram is plotted, with the fitted model
drawn in transparent blue. Notice that a range of semi-variances can be
realized for a given distance because the model is anisotropic.

The fitted model overestimates the (partial sill) variance in this case
because there is an unaccounted-for trend. Ordinary kriging estimates
spatially constant trends, but here we should expect it to depend on how
near we are to the presumed source of the zinc deposits (the Meuse
River).

The code below demonstrates creating a linear predictor - the distance
to the river.

``` r
# display then copy some info about the grid
summary(g_meuse)
```

    ## incomplete geo-referenced sk grid
    ## 435240 points
    ## 155 observed
    ## range [4.73, 7.52]
    ## ..............................
    ## dimensions : 780 x 558
    ## resolution : 5 x 5
    ##     extent : [329715, 333610] x [178605, 181390]

``` r
gdim = dim(g_meuse)
is_obs = !is.na(g_meuse)
n = length(g_meuse)
n_obs = sum(is_obs)

# get distance values for entire grid
g_meuse_sf = sk_coords(g_meuse, out='sf')
```

    ## processing all 435240 grid points...

``` r
d2r_result = units::drop_units(st_distance(g_meuse_sf, meuse[['river_line']]))

# include both distance and its square root
X = g_meuse
X[] = scale(cbind(d2r_result, sqrt(d2r_result)))
plot(X, layer=1)
```

![](https://github.com/deankoch/snapKrig/blob/master/vignettes/meuse_vignette_files/figure-gfm/make_distances-1.png)<!-- -->

``` r
plot(X, layer=2)
```

![](https://github.com/deankoch/snapKrig/blob/master/vignettes/meuse_vignette_files/figure-gfm/make_distances-2.png)<!-- -->

``` r
# copy the subset of predictors at observed response locations
#X = matrix(meuse_predictors[is_obs,], nrow=n_obs)
```

Fit the model with the linear predictor included. This is called
universal kriging

``` r
# fit the model and plot semivariogram
fit_result_UK = sk_fit(g_obs=g_meuse, X=X, quiet=TRUE)

# print the GLS estimates for coefficients of the linear predictor
pars_UK = fit_result_UK$pars
sk_GLS(g_meuse, pars_UK, X=X, out='b')
```

    ## [1]  5.681607  1.238573 -1.884430

These fitted kernels can be visualized using `sk_plot_pars`. This plots
the footprint of correlations around any given central point on the
grid.

``` r
# plot the kernel shape
sk_plot_pars(pars_UK, g_meuse)
```

![](https://github.com/deankoch/snapKrig/blob/master/vignettes/meuse_vignette_files/figure-gfm/kernel_plot-1.png)<!-- -->

``` r
# print the actual contents of the parameters list
str(pars_UK)
```

    ## List of 4
    ##  $ y    :List of 2
    ##   ..$ k : chr "gau"
    ##   ..$ kp: Named num 233
    ##   .. ..- attr(*, "names")= chr "rho"
    ##  $ x    :List of 2
    ##   ..$ k : chr "gau"
    ##   ..$ kp: Named num 233
    ##   .. ..- attr(*, "names")= chr "rho"
    ##  $ eps  : num 0.0856
    ##  $ psill: num 0.0937

``` r
# GLS to estimate the (spatially varying) trend
g_lm = sk_GLS(g_meuse, pars_UK, X)
plot(g_lm, main='estimated trend component')
```

![](https://github.com/deankoch/snapKrig/blob/master/vignettes/meuse_vignette_files/figure-gfm/GLS_plot-1.png)<!-- -->

``` r
# g2 = g_meuse
# g2[['gval']] = g2[['gval']] - z_gls
# vg_detrend = sk_sample_vg(g2)
# sk_plot_semi(vg_detrend, pars_UK, fun='classical')
# sk_plot_semi(vg_detrend, pars_UK, fun='root_median')
```

Once you have a set of covariance parameters, interpolation becomes very
easy with `sk_cmean`. This computes the kriging predictor, an
interpolator with nice properties like unbiasedness and minimal
variance, under suitable assumptions.

``` r
# compute expectation (UK kriging predictor)
g_pred = sk_cmean(g_meuse, pars_UK, X)
```

``` r
# plot UK predictions, mask to observed range
zlim_pred = range(g_meuse, na.rm=TRUE)
plot(g_pred, zlim=zlim_pred, zlab='log(zinc)', main='kriging predictor')
```

![](https://github.com/deankoch/snapKrig/blob/master/vignettes/meuse_vignette_files/figure-gfm/unnamed-chunk-2-1.png)<!-- -->

Kriging variance is also computed with `sk_cmean`. This is much slower
to compute than the kriging predictor

``` r
# prediction variance
g_var = sk_cmean(g_meuse, pars_UK, X, what='v', quiet=TRUE)


# plot
plot(g_var, main='kriging variance', zlim=c(0, pars_UK[['psill']]))
```

![](https://github.com/deankoch/snapKrig/blob/master/vignettes/meuse_vignette_files/figure-gfm/variance_plot-1.png)<!-- -->

The above plots are for the variable on the log-scale. The unbiasedness
property is lost when transforming back to the original scale, but now
that we have the kriging variance, we can make a correction:

``` r
# prediction bias adjustment from log scale
g_pred_adj = exp(g_pred + g_var/2)

sk_plot(g_pred_adj, zlab='zinc (ppm)', main='UK predictions (masked to input range)', zlim=exp(zlim_pred))
```

![](https://github.com/deankoch/snapKrig/blob/master/vignettes/meuse_vignette_files/figure-gfm/predictor-1.png)<!-- -->

## Summary

This vignette is intended to get users up and running with `snapKrig` by
demonstrating a very simple example on a familiar dataset. In other
vignettes we will look in more detail at how `sk_cmean` actually works,
and how users can modify the workflow to incorporate a trend model.

## Markdown

This chunk below is used to create the markdown document you’re reading
from the R script file with same name, in this directory. It uses
`rmarkdown` to create the md file, then substitutes local image paths
for github URLs so the document will display the images properly on my
repo page.

``` r
if(FALSE)
{
  # Restart session and run code chunk below to build the markdown file
  library(here)
  library(rmarkdown)

  # make the markdown document and delete the unwanted html
  path.input = here('vignettes/meuse_vignette.R')
  path.output = here('vignettes/meuse_vignette.md')
  path.garbage = here('vignettes/meuse_vignette.html')
  rmarkdown::render(path.input, clean=TRUE, output_file=path.output)
  unlink(path.garbage)

  # substitute local file paths for image files with URLs on github
  md.github = gsub('https://github.com/deankoch/snapKrig/blob/master', 'https://github.com/deankoch/snapKrig/blob/master', readLines(path.output))
  writeLines(md.github, path.output)
}
```
