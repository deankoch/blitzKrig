% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sk_estim.R
\name{sk_GLS}
\alias{sk_GLS}
\title{Generalized least squares (GLS) with Kronecker covariances}
\usage{
sk_GLS(g, pars, X = NA, fac = NULL, fac_method = "eigen", out = "b")
}
\arguments{
\item{g}{a sk grid object (or list with entries 'gdim', 'gres', 'gval')}

\item{pars}{list of form returned by \code{sk_pars} (with entries 'y', 'x', 'eps', 'psill')}

\item{X}{matrix or NA, the linear predictors (in columns) excluding intercept}

\item{fac}{matrix or list, (optional) pre-computed covariance matrix factorization}

\item{fac_method}{character, factorization method: 'eigen' (default) or 'chol' (see \code{sk_var})}

\item{out}{character, either 'b' (coefficients) or 'z' (linear predictor)}
}
\value{
numeric vector, either b (default) or Xb (if \code{out='z'})
}
\description{
Computes coefficients b of the linear predictor E(Z) = Xb using the GLS equation,
the maximum likelihood estimator given sk grid data \code{g} covariance model \code{pars}.
If \code{out='z'}, the function returns the product Xb instead of b.
}
\details{
The GLS solution is: b = ( X^T V^{-1} X )^{-1} X^T V^{-1} z,

where V is the covariance matrix for data z (the non-\code{NA} entries of \code{g[]}), and X
is a matrix of covariates. V is generated from the covariance model specified by
\code{pars} for the grid \code{g}. Operations with V^{-1} are computed using the
factorization \code{fac}, or else as specified in \code{fac_method}.

Argument \code{X} should provide matrix X without the intercept column (a vector of 1's).
DO NOT include an intercept column in argument \code{X} or you will get collinearity errors
(the function doesn't check if its there already). \code{X} should have independent columns,
and its rows should match the entries of \code{g[]}, in order.

Use \code{X=NA} to specify an intercept-only model; ie to fit a spatially
constant mean. This replaces X in the GLS equation by a vector of 1's.

If \code{g[]} is a matrix (a multi-layer grid), the covariates in \code{X} are recycled
for each layer. Layers are assumed mutually independent and the GLS equation is evaluated
using the corresponding block-diagonal V. Note that this is equivalent to (but faster
than) calling \code{sk_GLS} separately on each layer with the same \code{X} and averaging the
resulting b estimates
}
\examples{
# set up example grid and covariance parameters
gdim = c(45, 31)
g_empty = sk(gdim)
n = length(g_empty)
pars = modifyList(sk_pars(g_empty, 'gau'), list(psill=2))

# generate spatial noise
g_noise = g_empty
g_noise[] = sk_sim(g_noise, pars)
plot(g_noise)

# generate some covariates
n_betas = 3
betas = rnorm(n_betas, 0, 10)
X = matrix(rnorm(n*(n_betas-1)), n)
X_all = cbind(1, X)
lm_actual = as.vector(X_all \%*\% betas)
g_lm = g_empty
g_lm[] = lm_actual
plot(g_lm)

# combine with noise to make "observed" data
g_obs = g_lm + g_noise

# find the GLS coefficients
betas_est = sk_GLS(g_obs, pars, X)
print(betas_est)
print(betas)

# compute trend as product of betas with X and intercept, or by setting out='z'
lm_est = X_all \%*\% betas_est
max( abs( sk_GLS(g_obs, pars, X, out='z') - lm_est ) )

# repeat with pre-computed eigen factorization (same result but faster)
fac_eigen = sk_var(g_obs, pars, fac_method='eigen', sep=TRUE)
betas_est_compare = sk_GLS(g_obs, pars, X, fac=fac_eigen)
max( abs( betas_est_compare - betas_est ) )

# missing data example
n_obs = 10
g_miss = g_obs
g_miss[ sort(sample.int(n, n-n_obs)) ] = NA
plot(g_miss)

# coefficient estimates still unbiased but less precise
betas_est = sk_GLS(g_miss, pars, X)
print(betas_est)
print(betas)

# set X to NA to estimate the spatially constant trend
sk_GLS(g_miss, pars, X=NA)

# generate some extra noise for 10-layer example
z_extra = lapply(seq(9), function(x) sk_sim(g_empty, pars))
g_multi = g_empty
g_multi[] = lm_actual + do.call(cbind, c(list(g_noise[]), z_extra))
betas_complete = sk_GLS(g_multi, pars, X)
print(betas_complete)
print(betas)

# repeat with missing data
is_obs = !is.na(g_miss)
g_multi[!is_obs,] = NA
betas_sparse = sk_GLS(g_multi, pars, X)
print(betas_sparse)
print(betas)
sk_GLS(g_multi, pars, NA)

}
\seealso{
sk
}
\concept{estimators}
